- 코드 작성의 목적은 문제 해결이다
- 코드를 구성하는 방법은 코드 품질의 기본적인 측면 중 하나이며, 코드를 잘 구성한다는 것은 간결한 추상화 계층을 만드는 것으로 귀결될 때가 없다

## 1. 널값 및 의사코드 귀약

- 많은 프로그래밍 언어네는 값(또는 참조/포인터)이 없다는 개념을 가지고 있다
- 이 개념을 표현하기 위해 널(null)값을 사용한다

## 2. 왜 추상화 계층을 만드는가?

- 코드 작성은 복잡한 문제를 계속해서 더 작은 하위 문제로 세분화하는 작업이다
- 서버에 메세지 보내기에 코드 세줄과 4가지 간단한 개념만 다루면 된다
    - 서버의 URL, 연결, 메시지 문자열 보내기, 연결 닫기

```java
HttpConnection conntection = HttpConnection.connect("http://example.com/server");
connection.send("Hello Server");
connection.close();
```

- 이렇게 간단해 보이는 문제도 해결해야 할 하위 문제가 많다

![image.png](attachment:204353a9-c33d-4be7-87b8-2695cf0182c3:image.png)

- 문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로써 그 복잡한 문제를 쉽게 다룰 수 있다

### 2.1. 추상화 계층 및 코드 품질의 핵심 요소

- 깨끗하고 뚜렷한 추상화 계층을 구축하면 코드 품질의 네 가지 핵심요소를 달성할 수 있다
1. 가독성
    1. 모든 세부사항을 이해하는 것은 불가능하지만 몇 가지 높은 계층의 추상화를 이해하고 사용하기는 상당히 쉽다
2. 모듈화
    1. 구현 세부 사항이 외부로 노출되지 않도록 보장할 때, 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기 매우 쉬워진다
    2. 와이파이 사용하는 경우와 셀룰러 네트워크를 사용하는 모듈이 다르고, 상위 수준의 코드에서는 다양한 상황에 대처하기 위해 어떤 특별한 작업을 수행할 필요가 없다
3. 재사용성 및 일반화성
    1. 문제가 적절하게 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 사왕에서 유용하게 일반화될 가능성이 크다
    2. TCP/IP 및 네트워크 연결을 처리하는 시스템의 대부분은 웹소켓과 같은 다른 유형의 연결에 필요한 하위 문제를 해결하는 데도 사용될 수 있다
4. 테스트 용이성
    1. 집을 살 때도 외관만 보고 사지는 않을 것이다. 측량도 해보고, 벽에 금이 가지는 않았는지 확인할  것이다
    2. 신뢰할 수 있는 코드를 작성하려면, 각 하위 문제에 대한 해결책이 견고하고 제대로 작동하는지 확인해야 한다

## 3. 코드의 계층

- 추상화 계층을 생성하는 방법은 코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 보여주는 의존성 그래프를 생성하는 것이다
- 코드를 다른 단위로 나누기 위해 몇 가지 언어 요소를 자유롭게 사용할 수 있다
    - 함수
    - 클래스
    - 인터페이스
    - 패키지, 네임스페이스, 모듈

### 3.1 API 및 구현 세부 사항

- 코드를 작성할 때 고려해야 할 측면이 두 가지 있다
    - 코드를 호출 때 볼 수 있는 내용
        - 퍼블릭 클래스, 인터페이스 및 함수
        - 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
        - 코드 호출 시 코드를 올바르게 사용하기 위해 알아야 하는 추가 정보
    - 코드를 호출할 때 볼 수 없는 내용: 구현 세부 사항
- API는 서비스를 사용할 때 알아야 할 것들에 대한 개념을 형식화하고, 서비스의 모든 구현 세부 사항을 API 뒤에 감춘다
- API는 호출하는 쪽에 공개할 개념만 정의하면 나머지는 구현 세부사항이기 때문에 코드를 API의 관점에서 생각하면 추상화 계층을 명확하게 만드는 데 도움이 된다

### 3.2. 함수

- 함수가 너무 많은 작업을 하면 이해하기 어려워진다
- 함수가 하는 일을 다음 중 하나로 제한하면 이해하기 쉽고 단순한 문장으로 표현되는 함수를 작성할 수 있다
    - 단일 업무 수행
    - 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성
- 함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다
- 함수를 한 문장으로 표현하기 어렵게 구현했다면 로직의 일부를 잘 명명된 헬퍼 함수로 분리되는 것을 고려해봐야 한다

### 3.3. 클래스

- 개발자들은 단일 클래스의 이상적인 크기에 대해 논의하고 다음과 같은 많은 이론과 경험법칙을 제시한다
- 줄 수: 가끔 300줄을 넘지 않아야 한다 같은 가이드 라인이 있는데, 어떤 것이 옳다는 보장은 아니다
- 응집력: 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도로, 좋은 클래스는 응집력이 좋다
    - 순차적 응집력: 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생한다
        - 원두를 갈기 전에는 커피를 추출할 수 없다
        - 갈고 추출하는 것 사이에 서로 응집력이 있다고 결론지을 수 있다
    - 기능적 응집력: 이것은 몇 가지 요소들이 하나의 일을 성취하는 데 기여할 때 발생한다
        - 케이크를 만들기 위해 반죽을 섞을 그릇, 나무 숟가락, 테이크 통이 필요하며 함께 있어야 한다
    - 관심사 분리: 별개의 문제를 다르는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙이다
        - 게임 콘솔과 TV가 동일한 제품으로 묶이지 않는다
        - 원룸에서 살면 작은 TV를 사고, 아파트에 사는 사람은 큰 TV를 산다
        - 더 새롭고 더 빠른 게임기가 출시되더라도 TV를 새로  다시 살 필요가 없다
- 응집력과 관심사의 분리에 대해 생각할 때는 서로 관련된 여러 가지 사항을 하나의 사항으로 간주하는 것을 어느 수준까지 해야 유용할지 결정해야 한다
- 개발자가 신중하게 생각하지 않으면 클래스는 종종 너무 커진다
- 코드를 적절한 크기의 클래스로 세분화하는 것은 추상화 계층을 잘 만들기 위한 가장 효과적인 도구이기 때문에 이를 위한 시간과 노력을 들일 만한 가치가 충분히 있다

### 3.4. 인터페이스

- 인터페이스를 통해 계층 사이를 뚜렷이 구분하고 구현 세부 사항이 계층 사이에 유출되지 않도록 하기 위해 사용할 수 있는 접근법이 있다
- 두 가지 이상의 다른 방식으로 구현을 하거나 향후 다르게 구현할 것으로 예상되는 경우 인터페이스를 정의하는 것이 좋다

![image.png](attachment:a34388ae-b331-4c8f-99dc-d5f18bba7715:image.png)

- 추상화 계층을 깔끔하게 구현하는 코드를 만드는 데 있어 인터페이스 매우 유용한 도구다
- 퍼블릭 API를 매우 명확하게 보여준다
    - 인터페이스에만 의존하기 때문에 새 함수를 추가하더라도 노출되지 않는다
- 테스트를 쉽게 할 수 있다
    - 구현 클래스가 복잡하거나 네트워크 I/O에 의존하는 작업을 수행한다면 mock이나 페이크 객체로 대체할 수 있다
- 한 가지 구현만 필요하다고 잘못 추측할 것일 수 있다
    - 가정이 잘못되어서 완전 다른 방식으로 할 수 있다
- 같은 클래스로 두 가지 하위 문제를 해결할 수 있다
    - 예를들어 LinkdList 구현 클래스는 List 및 Queue 인터페이스 모두 구현한다
    - 어떤 상황에서는 큐의 구현클래스가 되고 다른 상황에서는 리스트의 구현 클래스로 사용될 수 있다
- 장점이 확실한 상황에서는 인터페이스를 사용하되, 인터페이스만을 위한 인터페이스를 작성해서는 안된다
- 그럼에도 깨끗하고 뚜렷한 추상화 계층을 만드는 데 집중하는 것은 여전히 중요하다
- 일반적으로 클래스를 작성하거나 수정할 때마다 나중에 필요한 경우 인터페이스를 붙이는 것이 어려워지지 않도록 코드를 작성해야 한다

### 3.5. 층이 너무 얇아질 때

- 코드를 별개의 계층으로 세분화하면 장점이 많지만 다음과 같은 추가 비용이 발생한다
    - 로직의 이해를 위해 더 많은 노력이 필요하다
    - 인터페이스 뒤에 계층을 숨기게 되면 파악하는 데 더 많은 노력이 필요하다
- 계층을 몇 개로 나눌지는 해결하려고 하는 실제 현실의 문제에 달려 있다
- 코드의 가독성을 높이고, 재사용할 수 있고, 일반화할 수 있으며, 모듈화되고, 테스트를 용이하게 하는지를 스스로 판단하고 신중하게 생각해야 한다

## 4. 마이크로서비스

- 마이크로서비스 자체가 간결한 추상화 계층을 제공하기 때문에 코드 구조를 만들고 코드에 추상화 계층을 만드는 것은 중요하지 않다는 주장이 있을 수 있다
- 하지만 재고에 대한 서비스를 제공한다고 해도
    - 제품 입고, 재고 확인, 제품 구매
- 재고 수준 관리라고 해도 하위 문제가 많다는 것을 알 수 있다
- 마이크로서비스는 시스템을 준리하여 보다 모듈화할 수 있는 매우 좋은 방법이지만, 서비스를 구현하기 위해 여러 하위 문제를 해결해야 한다는 사실은 바뀌지 않는다